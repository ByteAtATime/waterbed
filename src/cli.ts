#!/usr/bin/env bun

import fs from "fs/promises";
import path from "path";

const outputPathArg = process.argv[2];
const OUTPUT_FILE_PATH = outputPathArg
  ? path.resolve(process.cwd(), outputPathArg)
  : path.join(process.cwd(), "src/generated-schema.ts");

const toCamelCase = (str: string): string =>
  str
    .replace(/[^a-zA-Z0-9\s]/g, "")
    .trim()
    .toLowerCase()
    .split(/\s+/)
    .map((word, index) =>
      index === 0 ? word : word.charAt(0).toUpperCase() + word.slice(1)
    )
    .join("");

type AirtableField = {
  id: string;
  name: string;
  description?: string;
  type: string;
  options?: {
    isReversed?: boolean;
    linkedTableId?: string;
    prefersSingleRecordLink?: boolean;
    inverseLinkFieldId?: string;
  };
};

interface AirtableTable {
  id: string;
  name: string;
  description?: string;
  fields: AirtableField[];
  primaryFieldId: string;
  views: {
    id: string;
    name: string;
    type: string;
  }[];
}

interface AirtableBaseSchema {
  tables: AirtableTable[];
}

class AirtableMetadataAPI {
  private apiKey: string;
  private headers: Record<string, string>;

  constructor(apiKey: string) {
    if (!apiKey) {
      throw new Error("Airtable API key is required.");
    }
    this.apiKey = apiKey;
    this.headers = {
      Authorization: `Bearer ${this.apiKey}`,
    };
  }

  async getBaseSchema(baseId: string): Promise<AirtableBaseSchema> {
    const url = `https://api.airtable.com/v0/meta/bases/${baseId}/tables`;
    const response = await fetch(url, { headers: this.headers });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(
        `Airtable Metadata API request failed with status ${response.status}: ${errorText}`
      );
    }
    return response.json() as Promise<AirtableBaseSchema>;
  }
}

async function runIntrospection() {
  console.log("Starting Airtable base introspection...");

  const apiKey = process.env.AIRTABLE_API_KEY;
  const baseId = process.env.AIRTABLE_BASE_ID;

  if (!apiKey || !baseId) {
    console.error(
      "Error: AIRTABLE_API_KEY and AIRTABLE_BASE_ID must be set in your .env file."
    );
    process.exit(1);
  }

  const api = new AirtableMetadataAPI(apiKey);

  try {
    const schema = await api.getBaseSchema(baseId);
    console.log(
      `Found ${schema.tables.length} tables. Generating schema file...`
    );

    const tableIdToNameMap = new Map(schema.tables.map((t) => [t.id, t.name]));
    const tableVarNames: string[] = [];

    let schemaContent = `// This file is auto-generated. Do not edit this file directly.

import { table, text, number, boolean, attachment, multipleAttachments } from 'waterbed';

`;

    for (const table of schema.tables) {
      const tableVarName = toCamelCase(table.name);
      tableVarNames.push(tableVarName);

      schemaContent += `// Table: ${table.name}\n`;
      schemaContent += `export const ${tableVarName} = table('${table.name}', {\n`;

      for (const field of table.fields) {
        const jsKey = toCamelCase(field.name);
        let ormType = "text";
        let typeComment = "";

        switch (field.type) {
          case "singleLineText":
          case "multilineText":
          case "richText":
          case "email":
          case "url":
          case "phone":
            ormType = "text";
            break;
          case "number":
          case "currency":
          case "percent":
          case "rating":
            ormType = "number";
            break;
          case "checkbox":
            ormType = "boolean";
            break;
          case "attachment":
            ormType = "attachment";
            break;
          case "multipleAttachments":
            ormType = "multipleAttachments";
            break;
          case "multipleRecordLinks":
            const linkedTableName = tableIdToNameMap.get(
              field.options?.linkedTableId ?? ""
            );
            typeComment = `// Linked Record to "${linkedTableName}". Type 'link' not yet implemented.`;
            break;
          default:
            typeComment = `// Airtable type "${field.type}" is not yet supported.`;
            break;
        }

        schemaContent += `    ${jsKey}: ${ormType}('${field.name}'), ${typeComment}\n`;
      }

      if (table.views && table.views.length > 0) {
        schemaContent += `\n    views: {\n`;
        for (const view of table.views) {
          const jsKey = toCamelCase(view.name);
          schemaContent += `        '${jsKey}': ${JSON.stringify(
            view.name
          )},\n`;
        }
        schemaContent += `    },\n`;
      }

      schemaContent += `});\n\n`;
    }

    schemaContent += `\nexport const schema = {\n`;
    for (const tableVarName of tableVarNames) {
      schemaContent += `    ${tableVarName},\n`;
    }
    schemaContent += `};\n`;

    await fs.mkdir(path.dirname(OUTPUT_FILE_PATH), { recursive: true });
    await fs.writeFile(OUTPUT_FILE_PATH, schemaContent, "utf-8");
    console.log(
      `âœ… Introspection complete! Schema written to ${OUTPUT_FILE_PATH}`
    );
  } catch (error) {
    console.error("Introspection failed:", error);
    process.exit(1);
  }
}

runIntrospection();