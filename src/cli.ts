#!/usr/bin/env bun

import fs from "fs/promises";
import path from "path";

const OUTPUT_FILE_PATH = path.join(process.cwd(), "src/generated-schema.ts");

function toCamelCase(str: string): string {
  return str
    .replace(/[^a-zA-Z0-9\s]/g, "")
    .replace(/(?:^\w|[A-Z]|\b\w)/g, (word, index) =>
      index === 0 ? word.toLowerCase() : word.toUpperCase()
    )
    .replace(/\s+/g, "");
}

interface AirtableField {
  id: string;
  name: string;
  description?: string;
  type: string;
  options?: {
    isReversed?: boolean;
    linkedTableId?: string;
    prefersSingleRecordLink?: boolean;
    inverseLinkFieldId?: string;
  };
}

interface AirtableTable {
  id: string;
  name: string;
  description?: string;
  fields: AirtableField[];
  primaryFieldId: string;
  views: {
    id: string;
    name: string;
    type: string;
  }[];
}

interface AirtableBaseSchema {
  tables: AirtableTable[];
}

class AirtableMetadataAPI {
  private apiKey: string;
  private headers: Record<string, string>;

  constructor(apiKey: string) {
    if (!apiKey) {
      throw new Error("Airtable API key is required.");
    }
    this.apiKey = apiKey;
    this.headers = {
      Authorization: `Bearer ${this.apiKey}`,
    };
  }

  async getBaseSchema(baseId: string): Promise<AirtableBaseSchema> {
    const url = `https://api.airtable.com/v0/meta/bases/${baseId}/tables`;
    const response = await fetch(url, { headers: this.headers });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(
        `Airtable Metadata API request failed with status ${response.status}: ${errorText}`
      );
    }
    return response.json() as Promise<AirtableBaseSchema>;
  }
}

async function runIntrospection() {
  console.log("Starting Airtable base introspection...");

  const apiKey = process.env.AIRTABLE_API_KEY;
  const baseId = process.env.AIRTABLE_BASE_ID;

  if (!apiKey || !baseId) {
    console.error(
      "Error: AIRTABLE_API_KEY and AIRTABLE_BASE_ID must be set in your .env file."
    );
    process.exit(1);
  }

  const api = new AirtableMetadataAPI(apiKey);

  try {
    const schema = await api.getBaseSchema(baseId);
    console.log(
      `Found ${schema.tables.length} tables. Generating schema file...`
    );

    const tableIdToNameMap = new Map(schema.tables.map((t) => [t.id, t.name]));

    let schemaContent = `// This file is auto-generated. Do not edit this file directly.

import { createAirtableSchema, text, number, boolean } from '@byteatatime/airtable';

export const schema = createAirtableSchema({
`;

    for (const table of schema.tables) {
      schemaContent += `    // Table: ${table.name}\n`;
      schemaContent += `    '${table.name}': {\n`;

      for (const field of table.fields) {
        const jsKey = toCamelCase(field.name);
        let ormType = "text";
        let typeComment = "";

        switch (field.type) {
          case "singleLineText":
          case "multilineText":
          case "richText":
          case "email":
          case "url":
          case "phone":
            ormType = "text";
            break;
          case "number":
          case "currency":
          case "percent":
          case "rating":
            ormType = "number";
            break;
          case "checkbox":
            ormType = "boolean";
            break;
          case "multipleRecordLinks":
            const linkedTableName = tableIdToNameMap.get(
              field.options?.linkedTableId ?? ""
            );
            typeComment = `// Linked Record to "${linkedTableName}". Type 'link' not yet implemented.`;
            break;
          default:
            typeComment = `// Airtable type "${field.type}" is not yet supported.`;
            break;
        }

        schemaContent += `        ${jsKey}: ${ormType}('${field.name}'), ${typeComment}\n`;
      }

      schemaContent += `    },\n`;
    }

    schemaContent += `});\n`;

    await fs.mkdir(path.dirname(OUTPUT_FILE_PATH), { recursive: true });
    await fs.writeFile(OUTPUT_FILE_PATH, schemaContent, "utf-8");
    console.log(
      `âœ… Introspection complete! Schema written to ${OUTPUT_FILE_PATH}`
    );
  } catch (error) {
    console.error("Introspection failed:", error);
    process.exit(1);
  }
}

runIntrospection();
